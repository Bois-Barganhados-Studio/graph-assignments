#include <vector>
#include <ostream>
#include <utility>
#include <unordered_set>

/// @brief A Depth First Search table that contains the lifetime and parent of each vertex found.
struct dfsTable
{
    std::vector<int> discTime,
        endTime,
        parent;
    dfsTable(size_t n);
};

/// @brief Simple non-directed graph adjacency list implementation.
class Graph
{
private:
    size_t start, n, m;
    std::vector<std::vector<int>> adjList;

    /// @brief Creates a connected graph with n edges in the instanced caller.
    void inline genMinConnectedGraph(int begin, int end);

    /// @brief Populates the graph based on the given density.
    /// @param A value from 0 to 100 representing the desity percentage of edges in each block.
    void inline populate(int begin, int end,  float density);
public:
    /// @brief Contructs a connected graph based on the given criteria.
    /// @param START Index to start using the vertex vector.
    /// @param N Number of vertices in the graph.
    /// @param K Minimun number of blocks in the graph.
    /// @param bDensity A value from 0 to 100 representing the desity percentage of edges in each block.
    Graph(size_t START, size_t N, size_t K, float bDensity);

    /// @brief Constructs a graph from the specified file (generated by @code{Graph::dump()}).
    /// @param filename the filename of the text file to be used.
    Graph(std::string filename);
    ~Graph();
    int getN();
    int getM();

    /// @brief Ostream operator overload to allow printing the graph with std::cout
    friend std::ostream &operator<<(std::ostream &os, Graph g);
    bool addEdge(int v, int w);
    void addVertex();
    void removeEdge(int v, int w);
    void removeVertex(int v);

    /// @brief Checks if the graph is connected using @code{Graph::bfs}.
    bool isConnected();

    /// @brief Dumps the graph into a text file.
    /// File struct:
    /// start n
    /// v w
    /// ...
    /// @param filename the filename of the text file to be used.
    void dump(std::string filename);

    /// @brief Depth First Search iterative algorithm.
    /// @param root The vertex where the search will start at.
    /// @return A table containing the lifetime and parent of each vertex found.
    dfsTable dfs(int root);

    /// @brief Breadth First Search iterative algorithm.
    /// @param s the root vertex of the search
    /// @param level A vector with size |V| to determine each vertex distance from @param s.
    void bfs(int s, std::vector<int> &level);
    
    /// @brief Method I - Finds Blocks by finding two disjoint paths between each vertex pair.
    std::vector<std::vector<int>> findBlocksByDisjointPaths();
    bool findTwoDisjointPaths(int s, int t, std::unordered_set<int> &share_block);
    
    /// @brief Method I (Improved) - Finds Blocks by finding cycles.
    std::vector<std::vector<int>> findBlocksByCycle();
    void findCycles(int s, std::vector<int> &level, std::vector<std::unordered_set<int>> &cycles);
    
    /// @brief Method II - Finds Blocks by removing vertices to find joints.
    std::vector<std::vector<int>> findBlocksByJoints();
    bool isJoint(int s);
    void jointDfs(int s, const std::unordered_set<int> &joints, std::vector<std::unordered_set<int>> &blocks, std::vector<int> &level);
    
    /// @brief Method III - Tarjan iterative algorithm for finding biconnected components.
    /// @return A table containing the blocks of biconnected components of the graph.
    std::vector<std::vector<std::pair<int, int>>> findBlocksByTarjan();
};
