#include "Graph.hpp"
#include <cstdlib> // srand, rand
#include <ctime> // time
#include <iterator>
#include <algorithm>
#include <iostream>
#include <fstream>

/// @brief Contructs a connected graph based on the given criteria.
/// @param start_ Index to start using the vertex vector.
/// @param n_ Number of vertices in the graph.
/// @param density A value from 0 to 100 representing the density percentage of the graph.
Graph::Graph(int start_, int n_, int density)
    : start(start_), n(n_ + start_), m(0), adjList(n, std::vector<int>())
{
    density = density > 100 || density < 0 ? DEFAULT_DENSITY : density;
    srand(time(NULL));
    genMinConnectedGraph();
    for (int v = start; v < n; v++) {
        for (int w = v + 1; w < n; w++) {
            int vDensity = ((float)adjList[v].size() / (float)(n - start - 1)) * 100;
            if (vDensity >= density) 
                break;
            if ((rand() % 100) < density) {
                addEdge(v, w);
            }
        }
    }
}

/// @brief Constructs a graph from the specified file (generated by @code {Graph::dump()}).
/// @param filename the filename of the text file to be used.
Graph::Graph(std::string filename)
{
    
    std::ifstream ifs;
    ifs.open(filename);
    ifs >> start >> n >> m;
    adjList = std::vector<std::vector<int>>(n, std::vector<int>());
    int v, w;
    while (ifs >> v >> w) {
        addEdge(v, w);
    }
    ifs.close();
}

/// @brief Creates a connected graph with n edges in the instanced caller.
void inline Graph::genMinConnectedGraph()
{
    std::vector<int> in, out;
    in.push_back(rand() % n + start);
    for (int i = start; i < n; i++)
        if (i != in[0])
            out.push_back(i);
    while (!out.empty()) {
        int i = rand() % out.size(),
        j = rand() % in.size();
        addEdge(in[j], out[i]);
        in.push_back(out[i]);
        out.erase(out.begin() + i);
    }
}

Graph::~Graph()
{
}

int Graph::getN()
{
    return n;
}

int Graph::getM()
{
    return m;
}

void Graph::addEdge(int v, int w)
{
    if (v < n && w < n && !std::count(adjList[v].begin(), adjList[v].end(), w)) {
        adjList[v].push_back(w);
        adjList[w].push_back(v);
        m++;
    }
}

void Graph::addVertex()
{
    adjList.push_back(std::vector<int>());
    n++;
}

void Graph::removeEdge(int v, int w) {
    if (v < start || w < start || v >= n || w >= n)
        return;
    if ((adjList[v].erase(std::remove(adjList[v].begin(), adjList[v].end(), w), adjList[v].end()) != adjList[v].end())
    && adjList[w].erase(std::remove(adjList[w].begin(), adjList[w].end(), v), adjList[w].end()) != adjList[v].end()) {
        m--;
    }
}

void Graph::removeVertex(int v) {
    if (v < 0) return;
    std::vector<int> tmp = adjList[v];
    for (const auto& it : tmp) {
        removeEdge(v, it);
    }
    adjList[v].push_back(-1);
}

/// @brief Checks if the graph is connected.
bool Graph::isConnected()
{
    std::vector<bool> found(n, false);
    for (int i = 0; i < start; i++)
        found[i] = true;
    std::vector<int> stack;
    stack.push_back(start);
    while (!stack.empty()) {
        int v = stack.back(); stack.pop_back();
        for (int w : adjList[v]) {
            if (!found[w]) {
                stack.push_back(w);
                found[w] = true;
            }
        }
    }
    return std::find(found.begin(), found.end(), false) == found.end();
}

/// @brief Dumps the graph into a text file.
/// @param filename the filename of the text file to be used.
void Graph::dump(std::string filename)
{   
    std::ofstream ofs;
    ofs.open(filename);
    ofs << start << " " << n << " " << m << "\n";
    for (int v = start; v < n; v++) {
        for (int w : adjList[v]) {
            ofs << v << " " << w << "\n";
        }
    }
    ofs.close();
}

/// @brief Ostream operator overload to allow printing the graph with std::cout
std::ostream & operator<<(std::ostream & os, Graph g)
{
    for (int i = g.start; i < g.n; i++) {
        os << "[" << i << "] = { ";
        std::copy(g.adjList[i].begin(), --g.adjList[i].end(), std::ostream_iterator<int>(os, ", "));
        os << g.adjList[i].back() << " }\n";
    }
    return os;
}