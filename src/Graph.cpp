#include "Graph.hpp"
#include <cstdlib> // srand, rand
#include <ctime> // time
#include <iterator>
#include <algorithm>
#include <fstream>

/// @brief Contructs a connected graph based on the given criteria.
/// @param start_ Index to start using the vertex vector.
/// @param n_ Number of vertices in the graph.
/// @param m_ Number of edges in the graph.
Graph::Graph(size_t start_, size_t n_, size_t m_)
    : start(start_), n(n_ + start_), m(0), adjList(n, std::vector<int>())
{
    size_t max_m = (((size_t)n_ * (n_ - 1)) / 2);
    int target = m_ > max_m ? max_m : m_;
    target = m_ < n_ - 1 ? n_ - 1 : m_;
    genMinConnectedGraph();
    populate(target);
    for (auto& v : adjList)
        std::sort(v.begin(), v.end());
}

/// @brief Creates a connected graph with n edges in the instanced caller.
void inline Graph::genMinConnectedGraph()
{
    srand(time(NULL));
    std::vector<int> in, out;
    in.push_back(rand() % n + start);
    for (int i = start; i < n; i++)
        if (i != in[0])
            out.push_back(i);
    while (!out.empty()) {
        int i = rand() % out.size(),
        j = rand() % in.size();
        addEdge(in[j], out[i]);
        in.push_back(out[i]);
        out.erase(out.begin() + i);
    }
}

/// @brief Populates the graph based on the given density.
/// @param target The target amount of edges.
void inline Graph::populate(size_t target)
{
    srand(time(NULL));
    std::vector<int> edges(target - m);
    for (auto& w : edges)
        w = (rand() % (n - start)) + start;    
    while (m < target) {
        for (int v = start; v < n; v++) {
            if (adjList[v].size() > (n - start - 1))
                continue;
            if (addEdge(v, edges.back()))
                edges.pop_back();
        }
    }
}

/// @brief Constructs a graph from the specified file (generated by @code {Graph::dump()}).
/// @param filename the filename of the text file to be used.
Graph::Graph(std::string filename)
{
    std::ifstream ifs;
    ifs.open(filename);
    ifs >> start >> n >> m;
    adjList = std::vector<std::vector<int>>(n, std::vector<int>());
    int v, w;
    while (ifs >> v >> w) {
        addEdge(v, w);
    }
    ifs.close();
}

Graph::~Graph()
{
}

int Graph::getN()
{
    return n;
}

int Graph::getM()
{
    return m;
}

/// @brief Ostream operator overload to allow printing the graph with std::cout
std::ostream & operator<<(std::ostream & os, Graph g)
{
    for (int i = g.start; i < g.n; i++) {
        os << "[" << i << "] = { ";
        std::copy(g.adjList[i].begin(), --g.adjList[i].end(), std::ostream_iterator<int>(os, ", "));
        os << g.adjList[i].back() << " }\n";
    }
    return os;
}

bool Graph::addEdge(int v, int w)
{
    bool success = false;
    if (v != w && v < n && w < n && !std::count(adjList[v].begin(), adjList[v].end(), w)) {
        adjList[v].push_back(w);
        adjList[w].push_back(v);
        m++;
        success = true;
    }
    return success;
}

void Graph::addVertex()
{
    adjList.push_back(std::vector<int>());
    n++;
}

void Graph::removeEdge(int v, int w) {
    if (v < start || w < start || v >= n || w >= n)
        return;
    if ((adjList[v].erase(std::remove(adjList[v].begin(), adjList[v].end(), w), adjList[v].end()) != adjList[v].end())
    && adjList[w].erase(std::remove(adjList[w].begin(), adjList[w].end(), v), adjList[w].end()) != adjList[v].end()) {
        m--;
    }
}

void Graph::removeVertex(int v) {
    if (v < 0) return;
    std::vector<int> tmp = adjList[v];
    for (const auto& it : tmp) {
        removeEdge(v, it);
    }
    adjList[v].push_back(-1);
}

/// @brief Checks if the graph is connected.
bool Graph::isConnected()
{
    std::vector<bool> found(n, false);
    for (int i = 0; i < start; i++)
        found[i] = true;
    std::vector<int> stack;
    stack.push_back(start);
    while (!stack.empty()) {
        int v = stack.back(); stack.pop_back();
        for (int w : adjList[v]) {
            if (!found[w]) {
                stack.push_back(w);
                found[w] = true;
            }
        }
    }
    return std::find(found.begin(), found.end(), false) == found.end();
}

/// @brief Dumps the graph into a text file.
/// File struct:
/// start n m
/// v w
/// ...
/// @param filename the filename of the text file to be used.
void Graph::dump(std::string filename)
{   
    std::ofstream ofs;
    ofs.open(filename);
    ofs << start << " " << n << " " << m << "\n";
    for (int v = start; v < n; v++) {
        for (int w : adjList[v]) {
            ofs << v << " " << w << "\n";
        }
    }
    ofs.close();
}

/// @brief Constructs a Depth First Search table.
/// @param n The size of the table.
dfsTable::dfsTable(size_t n)
    : discTime(n, 0), endTime(n, 0), parent(n, 0)
{
}

/// @brief Depth First Search iterative algorithm . 
/// @param root The vertex where the search will start at.
/// @return A table containing the lifetime and parent of each vertex found.
dfsTable Graph::dfs(int root)
{
    dfsTable res(n);
    std::vector<int> clojure, visitCount(n, 0);
    size_t t = 0;
    clojure.push_back(root);
    res.discTime[root] = ++t;
    while (!clojure.empty()) {
        int v = clojure.back();
        if (visitCount[v] < adjList[v].size()) {
            int w = adjList[v][visitCount[v]++];
            if (!res.discTime[w]) {
                res.parent[w] = v;
                res.discTime[w] = ++t;
                clojure.push_back(w);
            }
        } else {
            res.endTime[v] = ++t;
            clojure.pop_back();
        }
    }
    return res;
}