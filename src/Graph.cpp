#include "Graph.hpp"
#include <cstdlib> // srand, rand
#include <ctime> // time
#include <iterator>
#include <algorithm>
#include <fstream>
#include <unordered_set>
#include <deque>

/// @brief Contructs a connected graph based on the given criteria.
/// @param start_ Index to start using the vertex vector.
/// @param n_ Number of vertices in the graph.
/// @param m_ Number of edges in the graph.
Graph::Graph(size_t start_, size_t n_, size_t m_)
    : start(start_), n(n_ + start_), m(0), adjList(n, std::vector<int>())
{
    size_t max_m = (((size_t)n_ * (n_ - 1)) / 2);
    int target = m_ > max_m ? max_m : m_;
    target = m_ < n_ - 1 ? n_ - 1 : m_;
    genMinConnectedGraph();
    populate(target);
    for (auto& v : adjList)
        std::sort(v.begin(), v.end());
}

/// @brief Creates a connected graph with n edges in the instanced caller.
void inline Graph::genMinConnectedGraph()
{
    srand(time(NULL));
    std::vector<int> in, out;
    in.push_back(rand() % n + start);
    for (int i = start; i < n; i++)
        if (i != in[0])
            out.push_back(i);
    while (!out.empty()) {
        int i = rand() % out.size(),
        j = rand() % in.size();
        addEdge(in[j], out[i]);
        in.push_back(out[i]);
        out.erase(out.begin() + i);
    }
}

/// @brief Populates the graph based on the given density.
/// @param target The target amount of edges.
void inline Graph::populate(size_t target)
{
    srand(time(NULL));
    std::vector<int> edges(target - m);
    for (auto& w : edges)
        w = (rand() % (n - start)) + start;    
    while (m < target) {
        for (int v = start; v < n; v++) {
            if (adjList[v].size() > (n - start - 1))
                continue;
            if (addEdge(v, edges.back()))
                edges.pop_back();
        }
    }
}

/// @brief Constructs a graph from the specified file (generated by @code {Graph::dump()}).
/// @param filename the filename of the text file to be used.
Graph::Graph(std::string filename)
{
    std::ifstream ifs;
    ifs.open(filename);
    ifs >> start >> n >> m;
    adjList = std::vector<std::vector<int>>(n, std::vector<int>());
    int v, w;
    while (ifs >> v >> w) {
        addEdge(v, w);
    }
    ifs.close();
}

Graph::~Graph()
{
}

int Graph::getN()
{
    return n;
}

int Graph::getM()
{
    return m;
}

/// @brief Ostream operator overload to allow printing the graph with std::cout
std::ostream & operator<<(std::ostream & os, Graph g)
{
    for (int i = g.start; i < g.n; i++) {
        os << "[" << i << "] = { ";
        std::copy(g.adjList[i].begin(), --g.adjList[i].end(), std::ostream_iterator<int>(os, ", "));
        os << g.adjList[i].back() << " }\n";
    }
    return os;
}

bool Graph::addEdge(int v, int w)
{
    bool success = false;
    if (v != w && v < n && w < n && !std::count(adjList[v].begin(), adjList[v].end(), w)) {
        adjList[v].push_back(w);
        adjList[w].push_back(v);
        m++;
        success = true;
    }
    return success;
}

void Graph::addVertex()
{
    adjList.push_back(std::vector<int>());
    n++;
}

void Graph::removeEdge(int v, int w) {
    if (v < start || w < start || v >= n || w >= n)
        return;
    if ((adjList[v].erase(std::remove(adjList[v].begin(), adjList[v].end(), w), adjList[v].end()) != adjList[v].end())
    && adjList[w].erase(std::remove(adjList[w].begin(), adjList[w].end(), v), adjList[w].end()) != adjList[v].end()) {
        m--;
    }
}

void Graph::removeVertex(int v) {
    if (v < 0) return;
    std::vector<int> tmp = adjList[v];
    for (const auto& it : tmp) {
        removeEdge(v, it);
    }
    adjList[v].push_back(-1);
}

/// @brief Checks if the graph is connected.
bool Graph::isConnected()
{
    std::vector<bool> found(n, false);
    for (int i = 0; i < start; i++)
        found[i] = true;
    std::vector<int> stack;
    stack.push_back(start);
    while (!stack.empty()) {
        int v = stack.back(); stack.pop_back();
        for (int w : adjList[v]) {
            if (!found[w]) {
                stack.push_back(w);
                found[w] = true;
            }
        }
    }
    return std::find(found.begin(), found.end(), false) == found.end();
}

/// @brief Dumps the graph into a text file.
/// File struct:
/// start n m
/// v w
/// ...
/// @param filename the filename of the text file to be used.
void Graph::dump(std::string filename)
{   
    std::ofstream ofs;
    ofs.open(filename);
    ofs << start << " " << n << " " << m << "\n";
    for (int v = start; v < n; v++) {
        for (int w : adjList[v]) {
            ofs << v << " " << w << "\n";
        }
    }
    ofs.close();
}

/// @brief Constructs a Depth First Search table.
/// @param n The size of the table.
dfsTable::dfsTable(size_t n)
    : discTime(n, 0), endTime(n, 0), parent(n, 0)
{
}

/// @brief Depth First Search iterative algorithm . 
/// @param root The vertex where the search will start at.
/// @return A table containing the lifetime and parent of each vertex found.
dfsTable Graph::dfs(int root)
{
    dfsTable res(n);
    std::vector<int> clojure, visitCount(n, 0);
    size_t t = 0;
    clojure.push_back(root);
    res.discTime[root] = ++t;
    while (!clojure.empty()) {
        int v = clojure.back();
        if (visitCount[v] < adjList[v].size()) {
            int w = adjList[v][visitCount[v]++];
            if (!res.discTime[w]) {
                res.parent[w] = v;
                res.discTime[w] = ++t;
                clojure.push_back(w);
            }
        } else {
            res.endTime[v] = ++t;
            clojure.pop_back();
        }
    }
    return res;
}

std::vector<std::vector<int>> Graph::findBlocksByDisjointPaths()
{
    std::vector<std::vector<int>> blocks;
    std::vector<std::unordered_set<int>> shared_blocks(n);
    for (int v = start; v < n; v++) {
        for (int w = v + 1; w < n; w++) {
            if (shared_blocks[v].find(w) == shared_blocks[v].end()) {
                bogoTwoDisjointPaths(v, w, shared_blocks[v]);
            } 
            if (v != w && shared_blocks[v].find(w) != shared_blocks[v].end()) {
                shared_blocks[w].insert(v);
            }
        }
    }
    for (int v = start; v < n; v++) {
        auto& set = shared_blocks[v];
        if (set.empty()) 
            continue;
        set.insert(v);
        for (auto i = set.begin(); i != set.end(); i++) {
            if (*i == v) 
                continue;
            auto& set_i = shared_blocks[*i];
            for (auto j = set_i.begin(); j != set_i.end();) {
                if (set.find(*j) != set.end()) {
                    set_i.erase(j++);
                } else {
                    ++j;
                }
            }
        }
        
    }
    for (auto& it : shared_blocks) {
        if (!it.empty()) {
            std::vector tmp(it.begin(), it.end());
            std::sort(tmp.begin(), tmp.end());
            blocks.emplace_back(tmp);
            it.clear();
        }
    }
    return blocks;
}

bool Graph::bogoTwoDisjointPaths(int s, int t, std::unordered_set<int>& share_block)
{
    if (std::find(adjList[s].begin(), adjList[s].end(), t) != adjList[s].end()) {
        share_block.insert(t);
        return true;
    }
    std::vector<bool> stacked(n, false);
    std::vector<std::unordered_set<int>> paths;
    std::vector<int> clojure, visitCount(n, 0);
    clojure.push_back(s);
    stacked[s] = true;
    while (!clojure.empty()) {
        int v = clojure.back();
        if (visitCount[v] == adjList[v].size()) {
            stacked[v] = false;
            visitCount[v] = 0;
            clojure.pop_back();
        } else {
            while (visitCount[v] < adjList[v].size()) {
                int w = adjList[v][visitCount[v]++];
                if (w == t) {
                    std::unordered_set<int> tmp;
                    for (int i = 1; i < clojure.size(); i++)
                        tmp.insert(clojure[i]);
                    paths.emplace_back(tmp);
                } else if (!stacked[w]) {
                    clojure.push_back(w);
                    stacked[w] = true;
                    break;
                }
            }
        }
    }
    clojure.clear();
    stacked.clear();
    visitCount.clear();
    bool match = false;
    for (int i = 0; i < paths.size(); i++) {
        for (int j = i + 1; j < paths.size(); j++) {
            int min = i, max = j;
            if (paths[i].size() > paths[j].size()) {
                max = i;
                min = j;
            }
            for (int it : paths[min]) {
                match = paths[max].find(it) != paths[max].end();
                if (match) {
                    break;
                }
            }
            if (!match) {
                for (int it : paths[i])
                    share_block.insert(it);
                for (int it : paths[i])
                    share_block.insert(it);
                share_block.insert(t);
                return true;
            }
        }
    }
    return false;
}
